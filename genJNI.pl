#!/usr/bin/perl -w

# Strict checking
use strict;

# Standard Perl modules
use IO::Handle;
use Cwd;
use File::Basename;
use Carp;

# Set up to use local modules
BEGIN {
    use File::Basename;
    my ($name, $path) = fileparse $0;
    $path =~ s%/$%%o;
    unshift @INC, $path;
    $path = "$path/../../../scripts";  # for esgit, in case we need it
    unshift @INC, $path;
}
use esgit;   # For file comparison, rename, etc

# Make sure all output is in order
STDOUT->autoflush(1);
STDERR->autoflush(2);

sub usageAndDie {
    my $msg = shift;
    warn "$msg";
    die <<EOF

Usage:  $0  <descriptorFile>

Reads the given descriptor file and generates a C++ wrapper file for each Java class described in the descriptor file.
EOF
      ;
}

# Descriptor file format example (without # comment characters):
# class android/app/Activity
#     method getPreferences(I)Landroid/content/SharedPreferences;
#     method foo()V
# endclass
# class android_content_SharedPreferences
#     method getBoolean(Ljava/lang/String;Z)Z
#     method getString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
# endclass

# Client call example:
# ESJNI_android_app_Activity *activity = ESUtil::theAndroidActivity();
# ESJNI_android_content_SharedPreferences *prefs = activity->getPreferences(0);
# prefs->attach(jni);  // makes the object stick around until detach();
# jboolean jb = prefs->getBoolean(ESToJString("Foo", false);
# bool b = ESFromJBoolean(jb);
# jstring js = prefs->getString(ESToJString("Bar", ESToJString("barDefault"));
# std::string s = ESFromJString(js);

# or cleaner

# ESJBool esb = prefs->getBoolean("Foo", false);
# bool b = esb->asC();
# ESJString ess = prefs->getString("Bar", "barDefault");
# std::string s = ess->asC();

my $file = shift;
defined $file
  or usageAndDie "Missing parameter\n";

-e $file
  or usageAndDie "File does not exist: $file\n";

my ($inputLeaf, $path) = fileparse $file;
chdir $path
  or die "Couldn't cd to $path (directory containing $file): $!\n";

my $wd = cwd();
my $fullInputPath = "$wd/$inputLeaf";

my $outputHeader = "ESJNIDefs.hpp";
my $outputCPP = "ESJNIDefs.cpp";
my $outputProguard = "ESJNI-proguard.pro";

my $outputHeaderNew = "$outputHeader.new";
my $outputCPPNew = "$outputCPP.new";
my $outputProguardNew = "$outputProguard.pro";

unlink $outputHeaderNew;
unlink $outputCPPNew;
unlink $outputProguardNew;

open FILE, $inputLeaf
  or die "Couldn't read inputLeaf: $!\n";

open HEADER, ">$outputHeaderNew"
  or die "Couldn't create $outputHeaderNew: $!\n";

open CPP, ">$outputCPPNew"
  or die "Couldn't create $outputCPPNew: $!\n";

open PROGUARD, ">$outputProguardNew"
  or die "Couldn't create $outputProguardNew: $!\n";

print HEADER <<EOF
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//
//   $outputHeader
//
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//
//   This file contains the generated class definitions for Java classes, methods, and fields referenced from JNI.
//   It was generated from the descriptor file $inputLeaf.
//

#ifndef _ESJNIDEFS_HPP_
#define _ESJNIDEFS_HPP_

#include "ESJNI.hpp"

#include "jni.h"
EOF
  ;

print CPP <<EOF
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//
//   $outputCPP
//
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//   THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
//
//   This file contains the generated class definitions for Java classes, methods, and fields referenced from JNI.
//   It was generated from the descriptor file $inputLeaf.
//

#include "$outputHeader"

#include "ESErrorReporter.hpp"

#include <stdio.h>  // for NULL (?)
EOF
  ;

print PROGUARD <<EOF
#  THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
#  THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
#  THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
#
#  $outputProguard
#
#  THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
#  THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
#  THIS FILE IS AUTOGENERATED.  DO NOT EDIT.
#
#  This file contains the generated Proguard rules for the classes and methods that we wrap with ESJNI.
#  This will keep Proguard from obfuscating those methods and classes we need to call into from C++.
#
EOF
  ;

my $lineNumber = 0;
sub dieWithError {
    my $error = shift;
    $error =~ s/\n$//o;
    confess "$fullInputPath:$lineNumber: error: $error";
}

sub convertJavaPathToName {
    my $path = shift;
    $path =~ s/^L(.*);/$1/o;
    $path =~ s%/%.%go;
    $path =~ s/\$/./go;
    return $path;
}

sub convertJavaArgsToNames {
    my $t = shift;
    return [] if not defined $t;
    my @arr;
    while ($t ne "") {
        if ($t =~ s/^L([^;]+);//o) {
            push @arr, convertJavaPathToName $1;
        } elsif ($t =~ s/^Z//o) {
            push @arr, "boolean";
        } elsif ($t =~ s/^[CB]//o) {  # B is really byte
            push @arr, "char";
        } elsif ($t =~ s/^S//o) {
            push @arr, "short";
        } elsif ($t =~ s/^I//o) {
            push @arr, "int";
        } elsif ($t =~ s/^J//o) {
            push @arr, "long";
        } elsif ($t =~ s/^F//o) {
            push @arr, "float";
        } elsif ($t =~ s/^D//o) {
            push @arr, "double";
        } elsif ($t =~ s/^V//o) {
            push @arr, "void";
        } elsif ($t =~ s/^\[B//o) {
            push @arr, "Byte[]";
        } elsif ($t =~ s/^\[//o) {
            dieWithError "Java array types not yet implemented";
        } else {
            dieWithError "Type $t unrecognized";
        }
    }
    return join ",", @arr;
}

sub ESNameForJavaPath {
    my $javaPath = shift;
    my $esClassName = "ESJNI_$javaPath";
    $esClassName =~ s%[/\$]%_%go;
    return $esClassName;
}

sub getCallForType {
    my $t = shift;
    defined $t
      or dieWithError "No return type defined on method (use V for void)";
    while ($t ne "") {
        if ($t =~ s/^L([^;]+);//o) {
            return "CallObjectMethod";
        } elsif ($t =~ s/^Z//o) {
            return "CallBooleanMethod";
        } elsif ($t =~ s/^B//o) {  # B is really byte
            return "CallByteMethod";
        } elsif ($t =~ s/^C//o) {  # B is really byte
            return "CallCharMethod";
        } elsif ($t =~ s/^S//o) {
            return "CallShortMethod";
        } elsif ($t =~ s/^I//o) {
            return "CallIntMethod";
        } elsif ($t =~ s/^J//o) {
            return "CallLongMethod";
        } elsif ($t =~ s/^F//o) {
            return "CallFloatMethod";
        } elsif ($t =~ s/^D//o) {
            return "CallDoubleMethod";
        } elsif ($t =~ s/^V//o) {
            return "CallVoidMethod";
        } elsif ($t =~ s/^\[//o) {
            return "CallObjectMethod";
        } else {
            dieWithError "Type $t unrecognized";
        }
    }
    confess "Internal error for return type $t";
}

sub getFieldGetterForType {
    my $t = shift;
    defined $t
      or dieWithError "No return type defined on method (use V for void)";
    while ($t ne "") {
        if ($t =~ s/^L([^;]+);//o) {
            return "GetObjectField";
        } elsif ($t =~ s/^Z//o) {
            return "GetBooleanField";
        } elsif ($t =~ s/^B//o) {  # B is really byte
            return "GetByteField";
        } elsif ($t =~ s/^C//o) {  # B is really byte
            return "GetCharField";
        } elsif ($t =~ s/^S//o) {
            return "GetShortField";
        } elsif ($t =~ s/^I//o) {
            return "GetIntField";
        } elsif ($t =~ s/^J//o) {
            return "GetLongField";
        } elsif ($t =~ s/^F//o) {
            return "GetFloatField";
        } elsif ($t =~ s/^D//o) {
            return "GetDoubleField";
        } elsif ($t =~ s/^V//o) {
            return "GetVoidField";
        } elsif ($t =~ s/^\[//o) {
            dieWithError "Java array types not yet implemented";
        } else {
            dieWithError "Type $t unrecognized";
        }
    }
    confess "Internal error for return type $t";
}

sub getFieldSetterForType {
    my $t = shift;
    defined $t
      or dieWithError "No return type defined on method (use V for void)";
    while ($t ne "") {
        if ($t =~ s/^L([^;]+);//o) {
            return "SetObjectField";
        } elsif ($t =~ s/^Z//o) {
            return "SetBooleanField";
        } elsif ($t =~ s/^B//o) {  # B is really byte
            return "SetByteField";
        } elsif ($t =~ s/^C//o) {  # B is really byte
            return "SetCharField";
        } elsif ($t =~ s/^S//o) {
            return "SetShortField";
        } elsif ($t =~ s/^I//o) {
            return "SetIntField";
        } elsif ($t =~ s/^J//o) {
            return "SetLongField";
        } elsif ($t =~ s/^F//o) {
            return "SetFloatField";
        } elsif ($t =~ s/^D//o) {
            return "SetDoubleField";
        } elsif ($t =~ s/^V//o) {
            return "SetVoidField";
        } elsif ($t =~ s/^\[//o) {
            dieWithError "Java array types not yet implemented";
        } else {
            dieWithError "Type $t unrecognized";
        }
    }
    confess "Internal error for return type $t";
}

sub translateTypes {
    my $t = shift;
    return [] if not defined $t;
    my @arr;
    while ($t ne "") {
        if ($t =~ s/^L([^;]+);//o) {
            push @arr, ESNameForJavaPath $1;
        } elsif ($t =~ s/^Z//o) {
            push @arr, "ESJBool";
        } elsif ($t =~ s/^[CB]//o) {  # B is really byte
            push @arr, "char";
        } elsif ($t =~ s/^S//o) {
            push @arr, "jshort";
        } elsif ($t =~ s/^I//o) {
            push @arr, "jint";
        } elsif ($t =~ s/^J//o) {
            push @arr, "jlong";
        } elsif ($t =~ s/^F//o) {
            push @arr, "jfloat";
        } elsif ($t =~ s/^D//o) {
            push @arr, "jdouble";
        } elsif ($t =~ s/^V//o) {
            push @arr, "void";
        } elsif ($t =~ s/^\[B//o) {
            push @arr, "ESJNI_ByteArray";
        } elsif ($t =~ s/^\[//o) {
            dieWithError "Java array types not yet implemented";
        } else {
            dieWithError "Type $t unrecognized";
        }
    }
    return \@arr;
}

sub parseMethod {
    my $methodDescriptor = shift;
    my $isStatic = shift;
    $methodDescriptor =~ s/\s//go;
    my $hash = {};
    $methodDescriptor =~ m%([^\(]+)\(([^\)]*)\)(.*)$%
      or dieWithError "Improper method descriptor syntax: $methodDescriptor";
    #print "part 1: '$1'\n";
    #print "part 2: '$2'\n";
    #print "part 3: '$3'\n";
    $hash->{descriptor} = "($2)$3";
    $hash->{name} = $1;
    $hash->{javaName} = $1;
    my $returnType = $3;
    $hash->{javaArgs} = convertJavaArgsToNames $2;
    $hash->{args} = translateTypes $2;
    $hash->{returnType} = translateTypes $returnType;
    $hash->{javaReturnType} = convertJavaArgsToNames $returnType;
    $hash->{callFunction} = getCallForType $returnType;
    $hash->{isStatic} = $isStatic;
    $hash->{isStaticGetMethod} = $isStatic;
    if ($isStatic) {
        $hash->{callFunction} =~ s/^Call/CallStatic/o;
    }
    (scalar @{$hash->{returnType}}) == 1
      or die "Unexpected return type in method descriptor: $methodDescriptor";
    if (${$hash->{returnType}}[0] eq "ESJNI_ByteArray") {
        $hash->{returnValueCaster} = "static_cast<jbyteArray>";
    }
    return $hash;
}

sub parseCtor {
    my $methodDescriptor = shift;
    my $esClass = shift;
    $methodDescriptor =~ s/\s//go;
    my $hash = {};
    $methodDescriptor =~ m%\(([^\)]*)\)$%
      or dieWithError "Improper ctor descriptor syntax: $methodDescriptor";
    #print "part 1: '$1'\n";
    #print "part 2: '$2'\n";
    #print "part 3: '$3'\n";
    $hash->{descriptor} = "($1)V";
    $hash->{name} = "CreateJavaObject";
    $hash->{javaName} = "<init>";
    $hash->{args} = translateTypes $1;
    $hash->{javaArgs} = convertJavaArgsToNames $1;
    $hash->{returnType} = [$esClass];
    $hash->{callFunction} = "NewObject";
    $hash->{isStatic} = 1;
    $hash->{isStaticGetMethod} = 0;
    return $hash;
}

sub parseField {
    my $fieldDescriptor = shift;
    my $isStatic = shift;
    $fieldDescriptor =~ s/\s//go;
    my $hash = {};
    $fieldDescriptor =~ m%([^:]+):(.*)$%
      or dieWithError "Improper field descriptor syntax: $fieldDescriptor";
    #print "part 1: '$1'\n";
    #print "part 2: '$2'\n";
    $hash->{name} = $1;
    my $fieldType = $2;
    $hash->{descriptor} = $fieldType;
    $hash->{fieldType} = translateTypes $fieldType;
    $hash->{javaType} = convertJavaArgsToNames $fieldType;
    $hash->{getterFunction} = getFieldGetterForType $fieldType;
    $hash->{setterFunction} = getFieldSetterForType $fieldType;
    $hash->{isStatic} = $isStatic;
    if ($isStatic) {
        $hash->{getterFunction} =~ s/^Get/GetStatic/o;
        $hash->{setterFunction} =~ s/^Set/SetStatic/o;
    }
    (scalar @{$hash->{fieldType}}) == 1
      or die "Unexpected return type in field descriptor: $fieldDescriptor";
    return $hash;
}

sub typeAndSpacesForHeader {
    my $type = shift;
    my $numSpaces = 23 - (length $type);
    $numSpaces = 0 if $numSpaces < 0;
    return "    " . $type . (" " x $numSpaces);
}

my %friends;
my @classes;
my $currentClass;

sub emitClass {
    my $cls = shift;
    my $classLength = length $cls->{esClass};
    my $classWithSpacesForHeader = typeAndSpacesForHeader $cls->{esClass};
    print HEADER <<EOF

class $cls->{esClass} : public ESJNIBase {
 public:
                            $cls->{esClass}();
                            $cls->{esClass}(jobject obj);
                            $cls->{esClass}(const $cls->{esClass} &other);
EOF
      ;
    foreach my $isa (@{$cls->{isaMes}}) {
        print HEADER <<EOF

                            $cls->{esClass}(const $isa &other);
EOF
          ;
    }
    print HEADER <<EOF
$classWithSpacesForHeader \&operator=(const $cls->{esClass} &other);

$classWithSpacesForHeader getRetainedCopy(JNIEnv *jniEnv) const __attribute__((warn_unused_result));

#ifndef NDEBUG
    virtual std::string     className() const { return "$cls->{javaPath}"; };  // Because all of this code is generated, we can do this easily...
#endif

    // static methods
    static void             initAndRetain(JNIEnv *jniEnv);  // Obtains and retains Java handle to class; must be called before anything else
    static void             removeJClassRef(JNIEnv *jniEnv);  // Destroys the Java handle to class; called during shutdown to clean up

    // generated cast methods
EOF
      ;

    foreach my $castClass (@{$cls->{castoks}}) {
        my $castMethod = $castClass;
        $castMethod =~ s/^ESJNI//o;
        $castMethod = "castAs$castMethod";
        my $castClassWithSpacesForHeader = typeAndSpacesForHeader $castClass;
        print HEADER "$castClassWithSpacesForHeader &$castMethod() const __attribute__((warn_unused_result));\n";
    }

    print PROGUARD <<EOF

-keep class $cls->{javaName} {
EOF
      ;

    for my $method (@{$cls->{methods}}) {
        my $name = $method->{javaName};
        my $maybeStatic = "";
        my $returnType = "";
        if ($name eq "<init>") {
            $name = $cls->{javaName};
            $name =~ s/^.*\.([^\.]+)$/$1/o;
        } else {
            $returnType = "$method->{javaReturnType} ";
            $maybeStatic = $method->{isStatic} ? "static " : "";
        }
        print PROGUARD "    $maybeStatic$returnType$name($method->{javaArgs});\n";
    }

    foreach my $field (@{$cls->{fields}}) {
        my $maybeStatic = $field->{isStatic} ? "static " : "";
        print PROGUARD "    $maybeStatic$field->{javaType} $field->{name};\n";
    }

    print PROGUARD <<EOF
}
EOF
      ;

    print HEADER <<EOF

    // generated glue methods for Java calls
EOF
      ;
    print CPP <<EOF

// *************************************************************************
// *************************************************************************

// Class $cls->{esClass} (from Java path $cls->{javaPath})

// *************************************************************************
// *************************************************************************

/*static*/ jclass $cls->{esClass}::_javaClass = NULL;
EOF
      ;

    my $methodIDCount = 0;
    for my $method (@{$cls->{methods}}) {
        $methodIDCount++;
        my $methodIDField = "_methodID$methodIDCount" . "_$method->{name}";
        print CPP "/*static*/ jmethodID $cls->{esClass}::$methodIDField = 0;\n";
    }
    my $fieldIDCount = 0;
    for my $field (@{$cls->{fields}}) {
        $fieldIDCount++;
        my $fieldIDField = "_fieldID$fieldIDCount" . "_$field->{name}";
        print CPP "/*static*/ jfieldID $cls->{esClass}::$fieldIDField = 0;\n";
    }
    print CPP <<EOF

$cls->{esClass}::$cls->{esClass}()
{
}

$cls->{esClass}::$cls->{esClass}(jobject jobj)
:   ESJNIBase(jobj)
{
}

$cls->{esClass}::$cls->{esClass}(const $cls->{esClass} &other)
:   ESJNIBase(other)
{
}
EOF
      ;
    foreach my $isa (@{$cls->{isaMes}}) {
        print CPP <<EOF

$cls->{esClass}::$cls->{esClass}(const $isa &other)
:   ESJNIBase(other)
{
}
EOF
          ;
    }
    print CPP <<EOF

$cls->{esClass}::$cls->{esClass}(jobject jobj, bool retained)
:   ESJNIBase(jobj, retained)
{
}

$cls->{esClass}
$cls->{esClass}::getRetainedCopy(JNIEnv *jniEnv) const {
    ESAssert(_javaObject);
    return $cls->{esClass}(jniEnv->NewGlobalRef(_javaObject), true/*retained*/);
}

$cls->{esClass} &
$cls->{esClass}::operator=(const $cls->{esClass} &other) {
    _retained = other._retained;
    _javaObject = other._javaObject;
    return *this;
}

/*static*/ void
$cls->{esClass}::initAndRetain(JNIEnv *jniEnv) {
    ESAssert(_javaClass == NULL);  // Only call once
    jclass jcl = jniEnv->FindClass("$cls->{javaPath}");
    ESAssert(jcl);
    _javaClass = (jclass)jniEnv->NewGlobalRef(jcl);
    jniEnv->DeleteLocalRef(jcl);
}

/*static*/ void
$cls->{esClass}::removeJClassRef(JNIEnv *jniEnv) {
    ESAssert(_javaClass != NULL);
    ESAssert(_javaClass);
    jniEnv->DeleteGlobalRef(_javaClass);
    _javaClass = NULL;
}

// *****    Declared methods
EOF
      ;
    foreach my $castClass (@{$cls->{castoks}}) {
        my $castMethod = $castClass;
        $castMethod =~ s/^ESJNI//o;
        $castMethod = "castAs$castMethod";
        print CPP <<EOF

$castClass &
$cls->{esClass}::$castMethod() const {
    return *(($castClass *)this);
}
EOF
          ;
    }
    $methodIDCount = 0;
    foreach my $method (@{$cls->{methods}}) {
        $methodIDCount++;
        my $returnType = ${$method->{returnType}}[0];
        my $typeLength = length $returnType;
        my $typeLengthWithStatic = $typeLength;
        if ($method->{isStatic}) {
            $typeLengthWithStatic += 7;
        }
        my $numSpaces = 28 - $typeLength - 4;
        $numSpaces = 1 if ($numSpaces <= 0);
        my $maybeStatic = $method->{isStatic} ? "static " : "";
        print HEADER "    $maybeStatic$returnType";
        print HEADER (" " x $numSpaces);
        print HEADER "$method->{name}(";
        my $nameLength = length $method->{name};
        my $headerArgTypeColumn = 4 + $typeLengthWithStatic + $numSpaces + $nameLength + 1;
        my $cppArgTypeColumn = $classLength + 2 + $nameLength + 1;
        $maybeStatic = $method->{isStatic} ? "/*static*/ " : "";
        print CPP "\n$maybeStatic$returnType\n";
        print CPP "$cls->{esClass}::$method->{name}(";
        my $callParams = "";
        if (defined $method->{args}) {
            my $maxArgLength = length "JNIEnv";
            foreach my $arg (@{$method->{args}}) {
                my $argLength = length $arg;
                if ($argLength > $maxArgLength) {
                    $maxArgLength = $argLength;
                }
            }
            my $spacer = (" " x ($maxArgLength - (length "JNIEnv")));
            print HEADER "JNIEnv $spacer" . "*jniEnv";
            print CPP "JNIEnv $spacer" . "*jniEnv";
            my $argNumber = 0;
            foreach my $arg (@{$method->{args}}) {
                $argNumber++;
                print HEADER ",\n" . (" " x $headerArgTypeColumn);
                print CPP ",\n" . (" " x $cppArgTypeColumn);
                my $spacer = (" " x ($maxArgLength - (length $arg)));
                print HEADER "$arg $spacer" . "P$argNumber";
                print CPP "$arg $spacer" . "P$argNumber";
                $callParams .= ", P$argNumber";
                if ($arg eq "ESJNI_java_lang_String") {
                    $callParams .= ".toJObject(jniEnv)";
                } elsif ($arg =~ /^ESJNI_/) {
                    $callParams .= ".toJObject()";
                } elsif ($arg eq "ESJBool") {
                    $callParams .= ".toJBool()";
                }
            }
        } else {
            print HEADER "JNIEnv *jniEnv";
            print CPP "JNIENv *jniEnv";
        }
        my $mustUseResult = ($returnType =~ /^ESJNI_/o) ? " __attribute__((warn_unused_result))" : "";
        print HEADER ")$mustUseResult;\n";
        print CPP ") {\n";
        my $methodIDField = "_methodID$methodIDCount" . "_$method->{name}";
        my $getter;
        if (!$method->{isStatic}) {
            print CPP "    ESAssert(_javaObject); // Initialize first (retain is not necessary for the object)\n";
        }
        if ($method->{isStaticGetMethod}) {
            $getter = "GetStaticMethodID";
        } else {
            $getter = "GetMethodID";
        }
        print CPP <<EOF
    ESAssert(_javaClass);  // Call $cls->{esClass}::initAndRetain first
    if (!$methodIDField) {
        $methodIDField = jniEnv->$getter(_javaClass, "$method->{javaName}", "$method->{descriptor}");
        ESAssert($methodIDField);
    }
EOF
          ;
        my $object = $method->{isStatic} ? "_javaClass" : "_javaObject";
        my $expression = "jniEnv->$method->{callFunction}($object, $methodIDField$callParams)";
        if ($returnType eq "void") {
            print CPP "    $expression;\n";
            print CPP "    ESJNI_CHECK_AND_LOG_EXCEPTION(jniEnv);\n";
        } else {
            if (defined $method->{returnValueCaster}) {
                $expression = "$method->{returnValueCaster}($expression)";
            }
            print CPP "    $returnType returnValue = $returnType($expression);\n";
            print CPP "    ESJNI_CHECK_AND_LOG_EXCEPTION(jniEnv);\n";
            print CPP "    return returnValue;\n";
        }
        print CPP "}\n";
    }

    print HEADER <<EOF

    // generated glue methods for Java field get/set
EOF
      ;
    $fieldIDCount = 0;
    foreach my $field (@{$cls->{fields}}) {
        $fieldIDCount++;
        my $fieldType = ${$field->{fieldType}}[0];
        my $typeLength = length $fieldType;
        my $typeLengthWithStatic = $typeLength;
        if ($field->{isStatic}) {
            $typeLengthWithStatic += 7;
        }
        my $numSpaces = 28 - $typeLength - 4;
        $numSpaces = 1 if ($numSpaces <= 0);
        my $fieldGetter = $field->{name} . "Field";
        my $fieldSetter = "set" . (ucfirst $field->{name}) . "Field";
        my $maybeStatic = $field->{isStatic} ? "static " : "";
        my $maybeConst = $field->{isStatic} ? "" : " const";
        print HEADER "    $maybeStatic$fieldType";
        print HEADER (" " x $numSpaces);
        print HEADER "$fieldGetter(JNIEnv *jniEnv)$maybeConst;\n";
        $numSpaces = 20;   # 28 - 4 - 4
        if ($field->{isStatic}) {
            $numSpaces = 13;
        }
        print HEADER "    $maybeStatic" . "void";
        print HEADER (" " x $numSpaces);
        print HEADER "$fieldSetter(JNIEnv *jniEnv, $fieldType val);\n";

        print HEADER "    static bool             $field->{name}FieldValid(JNIEnv *jniEnv);\n";

        $maybeStatic = $field->{isStatic} ? "/*static*/ " : "";

        # Getter
        print CPP "\n$maybeStatic$fieldType\n";
        print CPP "$cls->{esClass}::$fieldGetter(JNIEnv *jniEnv)$maybeConst {\n";
        my $fieldIDField = "_fieldID$fieldIDCount" . "_$field->{name}";
        my $getter;
        if ($field->{isStatic}) {
            $getter = "GetStaticFieldID";
        } else {
            print CPP "    ESAssert(_javaObject); // Initialize first (retain is not necessary for the object)\n";
            $getter = "GetFieldID";
        }
        print CPP <<EOF
    ESAssert(_javaClass);  // Call $cls->{esClass}::initAndRetain first
    if (!$fieldIDField) {
        $fieldIDField = jniEnv->$getter(_javaClass, "$field->{name}", "$field->{descriptor}");
        ESAssert($fieldIDField);
    }
EOF
          ;
        my $object = $field->{isStatic} ? "_javaClass" : "_javaObject";
        if ($fieldType eq "void") {
            die "Field with type void $cls->{esClass}::$field->{name}\n";
        } else {
            #print CPP "    return $fieldType(jniEnv->" . "$field->{getterFunction}" . "($object, $fieldIDField, val));\n";
            print CPP "    return $fieldType(jniEnv->" . "$field->{getterFunction}" . "($object, $fieldIDField));\n";
        }
        print CPP "}\n";

        # Setter
        print CPP "\n$maybeStatic" . "void\n";
        print CPP "$cls->{esClass}::$fieldSetter(JNIEnv *jniEnv, $fieldType val) {\n";
        $fieldIDField = "_fieldID$fieldIDCount" . "_$field->{name}";
        if ($field->{isStatic}) {
            $getter = "GetStaticFieldID";
        } else {
            print CPP "    ESAssert(_javaObject); // Initialize first (retain is not necessary for the object)\n";
            $getter = "GetFieldID";
        }
        print CPP <<EOF
    ESAssert(_javaClass);  // Call $cls->{esClass}::initAndRetain first
    if (!$fieldIDField) {
        $fieldIDField = jniEnv->$getter(_javaClass, "$field->{name}", "$field->{descriptor}");
        ESAssert($fieldIDField);
    }
EOF
          ;
        $object = $field->{isStatic} ? "_javaClass" : "_javaObject";
        if ($fieldType eq "void") {
            die "Field with type void $cls->{esClass}::$field->{name}\n";
        } else {
            my $val .= "val";
            if ($fieldType eq "ESJNI_java_lang_String") {
                $val .= ".toJObject(jniEnv)";
            } elsif ($fieldType =~ /^ESJNI_/) {
                $val .= ".toJObject()";
            } elsif ($fieldType eq "ESJBool") {
                $val .= ".toJBool()";
            }
            print CPP "    jniEnv->" . "$field->{setterFunction}" . "($object, $fieldIDField, $val);\n";
        }
        print CPP "}\n";

        # Validity check
        print CPP "\n/*static*/ bool\n";
        print CPP "$cls->{esClass}::$field->{name}FieldValid(JNIEnv *jniEnv) {\n";
        $fieldIDField = "_fieldID$fieldIDCount" . "_$field->{name}";
        if ($field->{isStatic}) {
            $getter = "GetStaticFieldID";
        } else {
            $getter = "GetFieldID";
        }
        print CPP <<EOF
    ESAssert(_javaClass);  // Call $cls->{esClass}::initAndRetain first
    if (!$fieldIDField) {
        $fieldIDField = jniEnv->$getter(_javaClass, "$field->{name}", "$field->{descriptor}");
        if (jniEnv->ExceptionCheck()) {
            jniEnv->ExceptionClear();
        }
    }
    return $fieldIDField != NULL;
}
EOF
          ;
    }


    print HEADER <<EOF

  private:
                            $cls->{esClass}(jobject jobj, bool retained);

    static jclass           _javaClass;

EOF
      ;
    $methodIDCount = 0;
    foreach my $method (@{$cls->{methods}}) {
        $methodIDCount++;
        my $methodIDField = "_methodID$methodIDCount" . "_$method->{name}";
        print HEADER "    static jmethodID        $methodIDField;\n";
    }
    $fieldIDCount = 0;
    foreach my $field (@{$cls->{fields}}) {
        $fieldIDCount++;
        my $fieldIDField = "_fieldID$fieldIDCount" . "_$field->{name}";
        print HEADER "    static jfieldID        $fieldIDField;\n";
    }
    my $friendDescriptor = $friends{$cls->{esClass}};
    if (defined $friendDescriptor) {
        foreach my $friendClass (keys %$friendDescriptor) {
            print HEADER "friend class $friendClass;\n";
        }
    }
    print HEADER "};\n";
}

sub checkFriend {
    my $friender = shift;
    my $friend = shift;
    my $friendDescriptor = $friends{$friender};
    if (defined $friendDescriptor) {
        $friendDescriptor->{$friend} = 1;
    } else {
        $friends{$friender} = { $friend => 1 };
    }
}

my %classesByName;

while (<FILE>) {
    ++$lineNumber;
    s/#.*$//go;
    if (/^\s*class\s*(\S+)\s*$/o) {
        my $javaPath = $1;
        if (defined $currentClass) {
            dieWithError "class directive found ($javaPath) while another class ($currentClass->{javaPath}) active; use 'endclass'";
        }
        $currentClass = {};
        $currentClass->{javaPath} = $javaPath;
        $currentClass->{javaName} = convertJavaPathToName $javaPath;
        $currentClass->{methods} = [];
        $currentClass->{fields} = [];
        $currentClass->{castoks} = [];
        $currentClass->{isaMes} = [];  # Classes which isA me
        $currentClass->{esClass} = ESNameForJavaPath $javaPath;
        push @classes, $currentClass;
        $classesByName{$currentClass->{esClass}} = $currentClass;
    } elsif (/^\s*method\s*(.*)\s*$/o) {
        defined $currentClass
          or dieWithError "method directive found while not in class";
        my $methodDescriptor = $1;
        push @{$currentClass->{methods}}, parseMethod $methodDescriptor, 0;
    } elsif (/^\s*field\s*(.*)\s*$/o) {
        defined $currentClass
          or dieWithError "field directive found while not in class";
        my $fieldDescriptor = $1;
        push @{$currentClass->{fields}}, parseField $fieldDescriptor, 0;
    } elsif (/^\s*smethod\s*(.*)\s*$/o) {
        defined $currentClass
          or dieWithError "smethod directive found while not in class";
        my $methodDescriptor = $1;
        push @{$currentClass->{methods}}, parseMethod $methodDescriptor, 1;
    } elsif (/^\s*sfield\s*(.*)\s*$/o) {
        defined $currentClass
          or dieWithError "sfield directive found while not in class";
        my $fieldDescriptor = $1;
        push @{$currentClass->{fields}}, parseField $fieldDescriptor, 1;
    } elsif (/^\s*endclass/o) {
        $currentClass = undef;
    } elsif (/^\s*friend\s*(.*)\s*$/o) {
        checkFriend($currentClass->{esClass}, $1);
    } elsif (/^\s*castok\s*(.*)\s*$/o) {
        my $castClass = ESNameForJavaPath $1;
        push @{$currentClass->{castoks}}, $castClass;
        checkFriend($castClass, $currentClass->{esClass});
    } elsif (/^\s*isa\s*(.*)\s*$/o) {
        my $castClassName = ESNameForJavaPath $1;
        my $castClass = $classesByName{$castClassName};
        defined $castClass
          or die "You must define $castClassName before using as isA in $currentClass->{esClass}\n";
        push @{$castClass->{isaMes}}, $currentClass->{esClass};
        checkFriend($castClassName, $currentClass->{esClass});
    } elsif (/^\s*ctor\s*(.*)\s*$/o) {
        defined $currentClass
          or dieWithError "ctor directive found while not in class";
        my $ctorDescriptor = $1;
        unshift @{$currentClass->{methods}}, parseCtor $ctorDescriptor, $currentClass->{esClass};
    } elsif (/\S/) {
        dieWithError "Unrecognized directive\n";
    } else {
        # empty line, ignore
    }
}

close FILE;

print HEADER "\n// Master static initialization of all defined wrapper classes:\n";
print HEADER "void ESJNI_initAndRetainAll(JNIEnv *jniEnv);\n";

print CPP "\n// Master static initialization of all defined wrapper classes:\n";
print CPP "void ESJNI_initAndRetainAll(JNIEnv *jniEnv) {\n";
foreach my $class (@classes) {
    print CPP "    $class->{esClass}::initAndRetain(jniEnv);\n";
}
print CPP "}\n";

print HEADER "\n// Master static shutdown of all defined wrapper classes:\n";
print HEADER "void ESJNI_shutdownAll(JNIEnv *jniEnv);\n";

print CPP "\n// Master static shutdown of all defined wrapper classes:\n";
print CPP "void ESJNI_shutdownAll(JNIEnv *jniEnv) {\n";
foreach my $class (@classes) {
    print CPP "    $class->{esClass}::removeJClassRef(jniEnv);\n";
}
print CPP "}\n";

print HEADER "\n// Forward decls\n";
foreach my $class (@classes) {
    print HEADER "class $class->{esClass};\n";
}

print HEADER "\n// Class definitions\n";
foreach my $class (@classes) {
    emitClass $class;
}

print HEADER "#endif  // _ESJNIDEFS_HPP_\n";

close HEADER;
close CPP;
close PROGUARD;

my $doDiff = 1;
checkForChanges $outputHeader, $outputHeaderNew, $doDiff, "$outputHeader.old";
checkForChanges $outputCPP, $outputCPPNew, $doDiff, "$outputCPP.old";
checkForChanges $outputProguard, $outputProguardNew, $doDiff, "$outputProguard.old";
